# as malloc.s -o malloc.o -g; ld malloc.o -o malloc -g
.section .data
    INI_HEAP: .quad 0
    FIM_HEAP: .quad 0 
    END_A: .quad 0
    END_B: .quad 0
    END_C: .quad 0
    MINIMO: .quad 0
    END_MINIMO: .quad 0
.section .text
.globl _start
iniciaAlocador:
    pushq %rbp
    movq %rsp, %rbp

    movq $12, %rax        # inicializa a heap alterando seu valor
    movq $0, %rdi
    syscall

    movq %rax, INI_HEAP   # move o valor atual de brk para INI_HEAP
    movq %rax, FIM_HEAP   # move o valor atual de brk para FIM_HEAP

    popq %rbp
    ret

finalizaAlocador:
    pushq %rbp
    movq %rsp, %rbp

    movq $12, %rax
    movq INI_HEAP, %rdi
    syscall

    popq %rbp
    ret
       
alocaMem:
    pushq %rbp
    movq %rsp, %rbp
    # subq $8, %rsp           # declara variavel local pra percorrer heap
    movq 16(%rbp), %rbx     # parâmetro num_bytes
    movq INI_HEAP, %r8     # passa inicio da heap para variavel local

    jmp procura_bloco_livre
    cmpq $0, %rax           # verifica valor de retorno da funcao
    jne fim                  # se foi encontrado bloco livre, encerra
    aloca_novo:             # se nao, aumenta heap
    movq 16(%rbp), %rbx     # parâmetro num_bytes
    movq $12, %rax          # caso a heap esteja vazia, aloca num_bytes
    addq FIM_HEAP, %rbx
    addq $16, %rbx
    movq %rbx, %rdi        # rbx = num_bytes + 16
    syscall    

    movq FIM_HEAP, %r8
    movq $1, (%r8)          # guarda que bloco esta ocupado
    movq 16(%rbp), %r9      # pega tamanho do bloco passado como parametro
    movq %r9, 8(%r8)       # guarda tamanho do bloco
    addq $16, %r8
    movq %r8, %rax
    movq %rbx, FIM_HEAP     # atualiza fim da heap

    fim:
    popq %rbp
    ret

procura_bloco_livre:
    movq INI_HEAP, %rbx
    movq 16(%rbp), %r8      # tamanho passado como parametro na pilha para bloco novo
    
    busca:
        cmpq %rbx, FIM_HEAP
        jle nao_tem_bloco_livre 

        cmpq $0, (%rbx)  # compara se o bloco esta livre comparando com 0, 0 = bloco livre!
        je bloco_livre   # se for 0, bloco disponivel para alocacao
    
        continua_busca:
        movq 8(%rbx), %r8  #
        addq %r8, %rbx
        addq $16, %rbx
        jmp busca

    bloco_livre:
    movq 8(%rbx), %r9       # r9 = tamanho do bloco encontrado
    cmpq %r9, %r8           # compara tamanho do bloco com tamanho desejado para alocacao 
    jl continua_busca       # se o bloco for menor, continua a busca
    movq $1, (%rbx)         # coloca 1 no bloco indicando que esta ocupado
    addq $16, %rbx          # acrescente 16 no endereco p/onde comeca o bloco
    movq %rbx, %rax         # retorna o endereco inicial do bloco
    jmp fim

    nao_tem_bloco_livre:
    movq $0, %rax
    jmp aloca_novo

liberaMem:
    push %rbp
    movq %rsp, %rbp
    movq 16(%rbp), %r8      # guarda o endereco do bloco passado como parametro p/liberacao

    ; movq -16(%r8), %rbx     # valor contido no bloco que diz se ta livre ou nao
    movq $0, -16(%r8)         # armazena valor indicando que o bloco esta livre
    movq -16(%r8), %rbx

    popq %rbp
    ret

best_fit:
    push %rbp
    movq %rsp, %rbp
    subq $8, %rsp         # aloca variavel local
    movq $0, -8(%rbp)     # guarda que inicialmente nao foi encontrado bloco livre, 0 = nao encontrado 1 = encontrado !!
    movq INI_HEAP, %rbx          
    movq 16(%rbp), %r8      # tamanho passado como parametro na pilha para bloco novo
    
    cmpq %rbx, FIM_HEAP
    je aloca_novo_bf
    movq %rbx, END_MINIMO   # endereco do primeiro bloco p/comparacao
    movq 8(%rbx), %r10
    movq %r10, MINIMO    # tamanho do primeiro bloco p/comparacao

    busca_bf:
        cmpq %rbx, FIM_HEAP
        jle aloca_mem_bf

        cmpq $0, (%rbx)  # compara se o bloco esta livre comparando com 0, 0 = bloco livre!
        je bloco_livre_bf   # se for 0, bloco disponivel para alocacao


        continua_busca_bf:
            movq 8(%rbx), %r8  #
            addq %r8, %rbx
            addq $16, %rbx
            jmp busca_bf

    bloco_livre_bf:
        movq $1, -8(%rbp)       # guarda que foi encontrado bloco livre
        movq 8(%rbx), %r9       # r9 = tamanho do bloco encontrado
        cmpq %r9, %r8           # compara tamanho do bloco com tamanho desejado para alocacao 
        jl continua_busca_bf       # se o bloco for menor, continua a busca
        cmpq MINIMO, %r9            # compara tamanho do bloco com o tamanho minimo, se for maior que o minimo, continua a busca
        jg continua_busca_bf
        movq %r9, MINIMO
        movq %rbx, END_MINIMO   # endereco do comeco do bloco minimo 
        jmp continua_busca_bf

    aloca_mem_bf:
        cmpq $1, -8(%rbp)       # verifica se variavel local tem 1, ou seja, foi enconrtado blocolivre !!
        jne aloca_novo_bf       # se nao, aloca novo bloco na heap
        movq END_MINIMO, %rbx   # endereco do bloco de tamanho minimo
        movq $1, (%rbx)         # coloca 1 no bloco indicando que esta ocupado
        addq $16, %rbx          # acrescente 16 no endereco p/onde comeca o bloco
        movq %rbx, %rax         # retorna o endereco inicial do bloco
        jmp fim_bf

    aloca_novo_bf:             # se nao, aumenta heap
        movq 16(%rbp), %rbx     # parâmetro num_bytes
        movq $12, %rax          # caso a heap esteja vazia, aloca num_bytes
        addq FIM_HEAP, %rbx
        addq $16, %rbx
        movq %rbx, %rdi        # rbx = num_bytes + 16
        syscall    

        movq FIM_HEAP, %r8
        movq $1, (%r8)          # guarda que bloco esta ocupado
        movq 16(%rbp), %r9      # pega tamanho do bloco passado como parametro
        movq %r9, 8(%r8)       # guarda tamanho do bloco
        addq $16, %r8
        movq %r8, %rax
        movq %rbx, FIM_HEAP     # atualiza fim da heap

    fim_bf:
        addq $8, %rsp
        popq %rbp
        ret


; next_fit:
    

_start:

    ; subq $16, %rsp            # declara espaço para duas variaveis locais longint  
    call iniciaAlocador

    movq $100, %rbx           # empilha num_bytes
    pushq %rbx  
    call best_fit
    addq $8, %rsp
    movq %rax, END_A       # guarda o endereco do primeiro bloco alocado

    movq $200, %rbx         # passa 200 como parametro de tamanho do bloco
    pushq %rbx
    call best_fit
    addq $8, %rsp
    movq %rax, END_B    # guarda o endereco do segundo bloco alocado

    movq $50, %rbx         # passa 50 como parametro de tamanho do bloco
    pushq %rbx
    call best_fit
    addq $8, %rsp
    movq %rax, END_C    # guarda o endereco do segundo bloco alocado

    movq END_A, %rbx
    pushq %rbx
    call liberaMem
    addq $8, %rsp

    movq END_C, %rbx
    pushq %rbx
    call liberaMem
    addq $8, %rsp
    
    movq $50, %rbx         # passa 50 como parametro de tamanho do bloco
    pushq %rbx
    call best_fit
    addq $8, %rsp
    movq %rax, END_C    # guarda o endereco do segundo bloco alocado

    call finalizaAlocador
    movq $60, %rax
    movq $0, %rdi
    syscall

    # print (longint) nome da variavel
    # info registers 

